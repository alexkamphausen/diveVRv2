<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting up Google Cardboard to web APIs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #webglviewer {
        bottom: 0;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div id="webglviewer"></div>

    <script src="./js/three.min.js"></script>
    <script src="./js/StereoEffect.js"></script>
    <script src="./js/DeviceOrientationControls.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="./js/Lut.js"></script>
    <script src="js/VTKLoader.js"></script>
    <!-- <script src="./js/helvetiker_regular.typeface.js"></script> -->
    <script src="https://cdn.timezonedb.com/js/timezonedb.min.js" type="text/javascript"></script>
		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec4 ca;
			varying vec4 vColor;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 150.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec4 vColor;
			void main() {
				vec4 outColor = texture2D( texture, gl_PointCoord );
				if ( outColor.a < 0.4 ) discard;
				gl_FragColor = outColor * vec4( color * vColor.xyz, 1 );
				float depth = gl_FragCoord.z / gl_FragCoord.w;
				const vec3 fogColor = vec3( 0.0 );
				float fogFactor = smoothstep( 200.0, 600.0, depth );
				gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
			}
		</script>
    <script>
      var scene,
          camera, 
          renderer,
          element,
          container,
          effect,
          controls,
          clock,

          // Particles
          particles = new THREE.Object3D(),
          totalParticles = 200,
          maxParticleSize = 200,
          particleRotationSpeed = 0,
          particleRotationDeg = 0,
          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3],

          // City and weather API set up
          cities = [['Sydney', '2147714'], ['New York', '5128638'], ['Tokyo', '1850147'], ['London', '2643743'], ['Mexico City', '3530597'], ['Miami', '4164138'], ['San Francisco', '5391959'], ['Rome', '3169070']],
          cityWeather = {},
          cityTimes = [],
          currentCity = 0,
          // currentCityText = new THREE.TextGeometry(),
          currentCityTextMesh = new THREE.Mesh();

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(1,1,1)
			  camera.lookAt(0,0,0);
			  camera.up.set(0,0,1);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        element = renderer.domElement;
        container = document.getElementById('webglviewer');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
          camera.position.x + 0.15,
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);

        var particle_size = 0.03; // 0.01 for github Dambreak | 0.005 for gearbox | 0.1 for fluid | propeller = 0.01
        var colormap_min = 0;  // min for Lookup Table [m/s]
        var colormap_max = 2.7;   // max for Lookup Table [m/s]
        // var filename = 'gearbox/gearbox_460.csv'       //  github datastorage
        // var filename = 'propeller/propeller_400.csv'   //  github data storage
        // var filename = 'fluid.csv'					   //  amazon S3 (don't use for testing) 
        var filename = 'propeller/propeller_reduced.csv'
        THREE.Cache.enabled = true;
            var loader = new THREE.FileLoader();
        loader.load('https://raw.githubusercontent.com/jobi2122/datastorage/master/' + filename, function (data) {
        console.log(data)

pointGeometry = new THREE.Geometry();
		    var positions = [];
			var velocities = [];
			var attributes;
			var particles = data.split(/\n/g);
			for ( var i = 0; i < particles.length; i++) {
				attributes = particles[i].split(",");
				velocities.push(new THREE.Vector3(
					parseFloat(attributes[0]), 
					parseFloat(attributes[1]), 
					parseFloat(attributes[2]))
				);
            	positions.push(new THREE.Vector3( 
            		parseFloat(attributes[3]), 
            		parseFloat(attributes[4]),
            		parseFloat(attributes[5]))
				);
			};
    		pointGeometry.vertices = positions;
			// console.log(positions);
			// console.log(velocities);
			var positions = new Float32Array( pointGeometry.vertices.length * 3 );
			var colors = new Float32Array( pointGeometry.vertices.length * 3 );
			var sizes = new Float32Array( pointGeometry.vertices.length );
			var vertex;
			var color = new THREE.Color();

			var lut = new THREE.Lut("rainbow", 255);
			lut.setMax(colormap_max);
			lut.setMin(colormap_min);
			
			for ( var i = 0; i < pointGeometry.vertices.length; i ++ ) {
				vertex = pointGeometry.vertices[ i ];
				vertex.toArray( positions, i * 3 );
				// color.setHSL( 0.6, 1, velocities[10].x / 2.8 );
				// var x_value = velocities[i].x
				var magnitude = Math.sqrt(Math.abs((velocities[i].x)^2 + (velocities[i].y)^2 + (velocities[i].z)^2))
				color = lut.getColor(magnitude);
				// console.log(magnitude)
				// color = lut.getColor(2);	
				color.toArray( colors, i * 3 );
    	    }

			//ColorMap
			// lut.setLegendOn[{layout:magnitude ,position:{x:5,y:5,z:5}, dimensions:{width:1,height:5}}]
			
			var geometry = new THREE.BufferGeometry();
			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'ca', new THREE.BufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
			for  (var i = 0; i < geometry.attributes.size.array.length; i++){
				geometry.attributes.size.array[i] = particle_size;  // particle size
			}
			var texture = new THREE.TextureLoader().load( "https://raw.githubusercontent.com/mrdoob/three.js/feefe06713cd6b44baaf5de8e58234a100275c8d/examples/textures/sprites/ball.png" );
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			var material = new THREE.ShaderMaterial( {
				uniforms: {
					amplitude: { value: 1 },
					color:     { value: new THREE.Color( 0xffffff ) },
					texture:   { value: texture }
				},
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent
			});
			object = new THREE.Points( geometry, material );
			scene.add( object );

			var geo = new THREE.PlaneBufferGeometry(5,5,5);
      var mat = new THREE.MeshBasicMaterial({ color: 0xbfbfbf, side: THREE.DoubleSide,transparent: true, opacity: 2, depthWrite: false });
      var plane = new THREE.Mesh(geo, mat);
			// plane.translateX(object_center.x);
			// plane.translateY( object_center.y);
			// plane.translateZ(object_center.z);
      scene.add(plane);

      clock = new THREE.Clock();

        animate();
      })
      }

      function lookupTimezones(t, len) {
        var tz = new TimeZoneDB;
        
        tz.getJSON({
            key: "GPH4A5Q6NGI1",
            lat: cityWeather[t].coord.lat,
            lng: cityWeather[t].coord.lon
        }, function(timeZone){
            cityTimes.push(new Date(timeZone.timestamp * 1000));

            t++;
        });
      }

      function animate() {
        var elapsedSeconds = clock.getElapsedTime(),
            particleRotationDirection = particleRotationDeg <= 180 ? -1 : 1;

        particles.rotation.y = elapsedSeconds * particleRotationSpeed * particleRotationDirection;
        
        // We check if the color range has changed, if so, we'll change the colours
        if (lastColorRange[0] != currentColorRange[0] && lastColorRange[1] != currentColorRange[1]) {

          for (var i = 0; i < totalParticles; i++) {
            particles.children[i].material.color.setHSL(currentColorRange[0], currentColorRange[1], (Math.random() * (0.7 - 0.2) + 0.2));
          }

          lastColorRange = currentColorRange;
        }

        requestAnimationFrame(animate);

        update(clock.getDelta());
        render(clock.getDelta());
      }

      function resize() {
        var width = container.offsetWidth;
        var height = container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
      }

      function render(dt) {
        effect.render(scene, camera);
      }

      function fullscreen() {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      }

      function getURL(url, callback) {
        var xmlhttp = new XMLHttpRequest();

        xmlhttp.onreadystatechange = function() {
          if (xmlhttp.readyState == 4) {
             if (xmlhttp.status == 200){
                 callback(JSON.parse(xmlhttp.responseText));
             }
             else {
                 console.log('We had an error, status code: ', xmlhttp.status);
             }
          }
        }

        xmlhttp.open('GET', url, true);
        xmlhttp.send();
      }
    </script>
  </body>
</html>
